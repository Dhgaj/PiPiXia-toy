# PiPiXia 词法分析 (Lexical Analysis)

本文档详细描述了 PiPiXia 编程语言的词法分析器实现。词法分析器负责将源代码文本转换为 Token 流，供语法分析器使用。

## 1. 基本信息

- **文件**: `lexical.l`
- **工具**: Flex 
- **功能**: 
  1. 识别关键字、运算符、字面量、标识符
  2. 处理注释和空白字符
  3. 处理转义字符
  4. 跟踪行号用于错误报告

## 2. 工具配置

```lex
%option noyywrap
%option yylineno
```

## 3. 正则表达式定义 (Pattern Definitions)

为了简化词法规则，定义了以下基础模式：

| 名称 | 模式 | 说明 |
|------|------|------|
| `DIGIT` | `[0-9]` | 数字 0-9 |
| `LETTER` | `[a-zA-Z_]` | 字母 a-z, A-Z 和下划线 |
| `IDENTIFIER` | `{LETTER}({LETTER}`&#124;`{DIGIT})*` | 标识符：字母开头，后跟字母或数字 |
| `INTEGER` | `{DIGIT}+` | 整数：一个或多个数字 |
| `DOUBLE` | `{DIGIT}+\.{DIGIT}+` | 浮点数：数字.数字 |
| `STRING` | `\"([^\"\\]`&#124;`\\.)*\"` | 字符串：双引号包围，支持转义 |
| `INTERPOL_STRING` | `\"([^\"\\]`&#124;`\\.)*\$\{([^\"\\]`&#124;`\\.)*\"` | 插值字符串：包含 `${...}` 的字符串 |
| `CHAR` | `'([^'\\]`&#124;`\\.)'` | 字符：单引号包围，支持转义 |
| `WHITESPACE` | `[ \t\r]+` | 空白字符：空格、制表符、回车 |
| `NEWLINE` | `\n` | 换行符 |

## 4. 词法规则 (Lexical Rules)

词法规则按优先级从上到下匹配。

### 4.1 注释处理

| 类型 | 模式 | 处理方式 |
|------|------|----------|
| 单行注释 | `"#".*` | 忽略到行尾 |
| 多行注释 | `"/#/"(.`&#124;`\n)*?"/#/"` | 忽略所有内容（包括换行） |

### 4.2 关键字 (Keywords)

必须在标识符规则之前匹配，否则会被识别为标识符。

#### 声明与函数
- `let`: 变量声明
- `const`: 常量声明
- `func`: 函数定义
- `return`: 返回语句

#### 控制流
- `if`, `else`: 条件语句
- `while`: 循环语句
- `for`, `in`: 迭代循环

#### 模块系统
- `import`: 导入模块
- `as`: 模块别名

#### 异常处理
- `try`: 尝试块
- `catch`: 捕获块
- `throw`: 抛出异常

#### 类型关键字
- `int`, `double`, `string`, `bool`, `char`

#### 布尔值
- `true`: 真 (`BOOL_LITERAL`)
- `false`: 假 (`BOOL_LITERAL`)

### 4.3 运算符 (Operators)

#### 算术运算符
- `+`: 加法
- `-`: 减法
- `*`: 乘法
- `/`: 除法
- `//`: 整除
- `%`: 取模

#### 比较运算符
- `==`: 等于
- `!=`: 不等于
- `<>`: 不等于 (替代语法)
- `<`: 小于
- `>`: 大于
- `<=`: 小于等于
- `>=`: 大于等于

#### 逻辑运算符
- `&&`: 逻辑与
- `||`: 逻辑或
- `!`: 逻辑非

#### 赋值运算符
- `=`: 基本赋值
- `+=`: 加法赋值
- `-=`: 减法赋值
- `*=`: 乘法赋值
- `/=`: 除法赋值
- `//=`: 整除赋值
- `%=`: 取模赋值

### 4.4 分隔符 (Delimiters)

- `(` `)`: 圆括号
- `{` `}`: 花括号
- `[` `]`: 方括号
- `,`: 逗号
- `:`: 冒号
- `;`: 分号
- `.`: 点号 (成员访问)
- `..`: 范围运算符

### 4.5 字面量处理 (Literals)

#### 数字
- **整数 (`INTEGER`)**: 使用 `atoi` 转换为整数值，返回 `INT_LITERAL`。
- **浮点数 (`DOUBLE`)**: 使用 `atof` 转换为浮点数值，返回 `DOUBLE_LITERAL`。
  > **注意**: `DOUBLE` 规则必须在 `INTEGER` 之前定义，因为 `INTEGER` 的模式可能会匹配 `DOUBLE` 的整数部分。

#### 字符串 (`STRING`)
返回 `STRING_LITERAL`。
1. 移除首尾的双引号。
2. 处理以下转义字符：
   - `\n` → 换行符
   - `\t` → 制表符
   - `\r` → 回车符
   - `\\` → 反斜杠
   - `\"` → 双引号
   - `\'` → 单引号
   - `\0` → 空字符 (在循环中跳过，避免字符串被截断)
   - `\b` → 退格符
   - `\f` → 换页符
   - `\v` → 垂直制表符
   - 其他 → 保持原样

#### 插值字符串 (`INTERPOL_STRING`)
返回 `INTERPOLATED_STRING`。
- **处理方式**: 保留原始字符串（包含引号和 `${...}` 占位符），后续交由语法分析器进行解析。

#### 字符 (`CHAR`)
返回 `CHAR_LITERAL`。
- **普通字符**: 直接取第二个字符（如 `'a'` 取 `a`）。
- **转义字符**: 识别 `\x` 格式，支持以下转义序列：
  - `\n` → 换行符
  - `\t` → 制表符
  - `\r` → 回车符
  - `\\` → 反斜杠
  - `\'` → 单引号
  - `\"` → 双引号
  - `\0` → 空字符
  - `\b` → 退格符
  - `\f` → 换页符
  - `\v` → 垂直制表符
  - 其他 → 保留转义后的字符

### 4.6 标识符与特殊处理

- **标识符 (`IDENTIFIER`)**: 匹配变量名、函数名等，返回 `IDENTIFIER` token。
- **空白字符 (`WHITESPACE`)**: 忽略空格、制表符和回车。
- **换行符 (`NEWLINE`)**: 忽略，但 Flex 会自动更新全局变量 `yylineno`。
- **错误处理**: 匹配任何未被上述规则识别的字符 (`.`)，打印错误信息 "Lexical error: Unknown character..." 并返回 `ERROR` token。

---

## 5. 词法分析示例

### 5.1 简单程序的词法分析

**输入代码**：
```ppx
func main(): int {
    let x: int = 42
    return x
}
```

**Token 流输出**：
```
FUNC
IDENTIFIER (main)
LPAREN
RPAREN
COLON
TYPE (int)
LBRACE
LET
IDENTIFIER (x)
COLON
TYPE (int)
ASSIGN
INT_LITERAL (42)
RETURN
IDENTIFIER (x)
RBRACE
```

### 5.2 插值字符串的词法分析

**输入代码**：
```ppx
let name: string = "Alice"
let greeting: string = "Hello, ${name}!"
```

**Token 流输出**：
```
LET
IDENTIFIER (name)
COLON
TYPE (string)
ASSIGN
STRING_LITERAL ("Alice")
LET
IDENTIFIER (greeting)
COLON
TYPE (string)
ASSIGN
INTERPOLATED_STRING ("Hello, ${name}!")
```

**注意**：插值字符串作为整体返回 `INTERPOLATED_STRING`，具体的表达式解析由语法分析器完成。

### 5.3 运算符识别示例

**输入代码**：
```ppx
let result: int = (a + b) * c / d
let isValid: bool = x >= 10 && y <= 20
```

**Token 流输出**：
```
LET IDENTIFIER(result) COLON TYPE(int) ASSIGN
LPAREN IDENTIFIER(a) PLUS IDENTIFIER(b) RPAREN
MULTIPLY IDENTIFIER(c) DIVIDE IDENTIFIER(d)

LET IDENTIFIER(isValid) COLON TYPE(bool) ASSIGN
IDENTIFIER(x) GE INT_LITERAL(10) AND
IDENTIFIER(y) LE INT_LITERAL(20)
```

---

## 6. 词法分析器实现细节

### 6.1 状态管理

词法分析器是无状态的，每次调用 `yylex()` 都会从当前位置读取下一个 token。

### 6.2 错误恢复

遇到非法字符时，词法分析器会：
1. 打印错误信息（包含行号和字符）
2. 返回 `ERROR` token
3. 继续分析后续内容

### 6.3 性能考虑

- **贪婪匹配**: Flex 使用贪婪匹配策略，优先匹配更长的模式
- **规则顺序**: 当多个规则匹配时，选择文件中先出现的规则
- **DFA 优化**: Flex 生成确定性有限自动机（DFA），保证 O(n) 时间复杂度

---

## 7. 实际应用

### 7.1 编译器中的调用

```cpp
#include "syntax.hh"

extern int yylex();
extern FILE* yyin;

int main(int argc, char** argv) {
    if (argc > 1) {
        yyin = fopen(argv[1], "r");
        if (!yyin) {
            perror("Cannot open file");
            return 1;
        }
    }
    
    int token;
    while ((token = yylex()) != 0) {
        // 处理每个 token
    }
    
    if (yyin != stdin) {
        fclose(yyin);
    }
    return 0;
}
```

### 7.2 Token 流输出（调试模式）

使用 `-token` 选项可以查看完整的 token 流：

```bash
./compiler program.ppx -token
```

**输出示例**：
```
Line 1: FUNC
Line 1: IDENTIFIER (main)
Line 1: LPAREN
Line 1: RPAREN
Line 1: COLON
Line 1: TYPE (int)
Line 1: LBRACE
Line 2: LET
Line 2: IDENTIFIER (x)
...
```

---

## 8. 常见问题

### 8.1 为什么整除是 `//` 而不是单个符号？

为了与 C/Java 的注释语法区分，PPX 使用 `//` 表示整除运算。单行注释使用 `#`。

### 8.2 插值字符串与普通字符串的区别

- **普通字符串**: 直接处理转义序列后返回
- **插值字符串**: 保留原始内容（包括 `${}`），由语法分析器进一步解析表达式

### 8.3 如何处理中文字符？

PPX 支持 UTF-8 编码：
- 字符串字面量中可以直接使用中文
- 标识符目前仅支持 ASCII 字符（a-z, A-Z, _, 0-9）
- 注释中可以使用任意 Unicode 字符

### 8.4 词法分析器性能如何？

Flex 生成的词法分析器性能非常高效：
- **时间复杂度**: O(n)，其中 n 是输入长度
- **空间复杂度**: O(1)，不计算输出的 token 流
- **内存占用**: 词法分析器本身占用很小的内存

---

## 9. 性能优化

### 9.1 词法规则优化

**规则顺序优化**：
- 将常用 token 的规则放在前面
- 将复杂正则表达式放在简单表达式之后
- 避免正则表达式的回溯

**示例**：
```lex
/* 好的顺序 */
{INTEGER}       { /* 常用，简单 */ }
{DOUBLE}        { /* 常用，较复杂 */ }
{STRING}        { /* 相对不常用，复杂 */ }
```

### 9.2 减少内存分配

**字符串处理优化**：
```cpp
// 不好的做法
std::string str = std::string(yytext);

// 好的做法
yylval.strVal = new std::string(yytext, yyleng);
```

### 9.3 缓冲区管理

Flex 默认使用 16KB 的输入缓冲区，对于大文件可以调整：

```lex
%option read=16384    /* 16KB 缓冲区（默认） */
```

---

## 10. 调试技巧

### 10.1 启用调试模式

在 Flex 文件中添加调试选项：

```lex
%option debug
```

然后在程序中启用：
```cpp
extern int yy_flex_debug;
yy_flex_debug = 1;  // 启用词法分析调试
```

### 10.2 打印 Token 流

在主程序中添加调试输出：

```cpp
int token;
while ((token = yylex()) != 0) {
    std::cout << "Token: " << token 
              << " at line " << yylineno 
              << std::endl;
}
```

### 10.3 处理边界情况

**测试用例**：
```ppx
# 空文件
# 只有注释的文件
# 超长标识符
# 特殊字符
# 未闭合的字符串
```

### 10.4 常见调试命令

```bash
# 查看生成的状态机
flex -d lexical.l

# 生成详细报告
flex -v lexical.l

# 查看性能统计
flex -p lexical.l
```

---

## 11. 最佳实践

### 11.1 代码组织

```lex
/* 1. 选项配置 */
%option noyywrap
%option yylineno

/* 2. C++ 代码区 */
%{
#include "syntax.hh"
%}

/* 3. 正则定义 */
DIGIT   [0-9]
LETTER  [a-zA-Z_]

/* 4. 词法规则 */
%%
{DIGIT}+    { return INT_LITERAL; }
%%

/* 5. 用户代码 */
```

### 11.2 错误处理策略

```lex
/* 捕获所有未识别字符 */
.   {
    fprintf(stderr, "Lexical error at line %d: '%c'\n", 
            yylineno, yytext[0]);
    return ERROR;
}
```

### 11.3 注释规范

```lex
/* 关键字：func、let、return 等 */
"func"      { return FUNC; }

/* 运算符：算术、逻辑、比较 */
"+"         { return PLUS; }

/* 字面量：整数、浮点数、字符串 */
{INTEGER}   { yylval.intVal = atoi(yytext); return INT_LITERAL; }
```

---

## 12. 扩展阅读

### 相关文档
- [语法分析文档](./语法分析.md) - Bison 语法分析器详解
- [编译器主程序](../main.cc) - 词法分析器的调用方式
- [Flex 规则文件](../lexical.l) - 完整的词法规则定义

### 外部资源
- [Flex 官方文档](https://github.com/westes/flex)
- [正则表达式教程](https://www.regular-expressions.info/)
- [编译原理：词法分析](https://en.wikipedia.org/wiki/Lexical_analysis)

---

## 13. 附录

### 附录 A：完整 Token 列表

| Token 类型 | 示例值 | 说明 |
|-----------|-------|------|
| `FUNC` | - | 函数关键字 |
| `LET` | - | 变量声明关键字 |
| `CONST` | - | 常量声明关键字 |
| `RETURN` | - | 返回语句关键字 |
| `IF` | - | 条件语句关键字 |
| `ELSE` | - | else 关键字 |
| `WHILE` | - | while 循环关键字 |
| `FOR` | - | for 循环关键字 |
| `IN` | - | in 关键字 |
| `BREAK` | - | break 关键字 |
| `CONTINUE` | - | continue 关键字 |
| `SWITCH` | - | switch 关键字 |
| `CASE` | - | case 关键字 |
| `DEFAULT` | - | default 关键字 |
| `TRY` | - | try 关键字 |
| `CATCH` | - | catch 关键字 |
| `THROW` | - | throw 关键字 |
| `IMPORT` | - | import 关键字 |
| `AS` | - | as 关键字 |
| `INT_LITERAL` | 42 | 整数字面量 |
| `DOUBLE_LITERAL` | 3.14 | 浮点数字面量 |
| `STRING_LITERAL` | "hello" | 字符串字面量 |
| `INTERPOLATED_STRING` | "Hi ${name}" | 插值字符串 |
| `CHAR_LITERAL` | 'A' | 字符字面量 |
| `BOOL_LITERAL` | true/false | 布尔字面量 |
| `IDENTIFIER` | userName | 标识符 |
| `TYPE` | int/double/string/bool/char | 类型名 |
| `PLUS` | + | 加法运算符 |
| `MINUS` | - | 减法运算符 |
| `MULTIPLY` | * | 乘法运算符 |
| `DIVIDE` | / | 除法运算符 |
| `FLOORDIV` | // | 整除运算符 |
| `MODULO` | % | 取模运算符 |
| `EQ` | == | 等于运算符 |
| `NE` | != | 不等于运算符 |
| `LT` | < | 小于运算符 |
| `GT` | > | 大于运算符 |
| `LE` | <= | 小于等于运算符 |
| `GE` | >= | 大于等于运算符 |
| `AND` | && | 逻辑与运算符 |
| `OR` | \|\| | 逻辑或运算符 |
| `NOT` | ! | 逻辑非运算符 |
| `ASSIGN` | = | 赋值运算符 |
| `PLUS_ASSIGN` | += | 加法赋值运算符 |
| `MINUS_ASSIGN` | -= | 减法赋值运算符 |
| `MULT_ASSIGN` | *= | 乘法赋值运算符 |
| `DIV_ASSIGN` | /= | 除法赋值运算符 |
| `FLOORDIV_ASSIGN` | //= | 整除赋值运算符 |
| `MOD_ASSIGN` | %= | 取模赋值运算符 |
| `LPAREN` | ( | 左圆括号 |
| `RPAREN` | ) | 右圆括号 |
| `LBRACE` | { | 左花括号 |
| `RBRACE` | } | 右花括号 |
| `LBRACKET` | [ | 左方括号 |
| `RBRACKET` | ] | 右方括号 |
| `COMMA` | , | 逗号 |
| `COLON` | : | 冒号 |
| `SEMICOLON` | ; | 分号 |
| `DOT` | . | 点号 |
| `DOTDOT` | .. | 范围运算符 |

### 附录 B：转义序列完整表

| 转义序列 | ASCII 码 | 含义 |
|---------|---------|------|
| `\n` | 10 | 换行符 (LF) |
| `\t` | 9 | 水平制表符 (HT) |
| `\r` | 13 | 回车符 (CR) |
| `\\` | 92 | 反斜杠 |
| `\"` | 34 | 双引号 |
| `\'` | 39 | 单引号 |
| `\0` | 0 | 空字符 (NUL) |
| `\b` | 8 | 退格符 (BS) |
| `\f` | 12 | 换页符 (FF) |
| `\v` | 11 | 垂直制表符 (VT) |

---

**PiPiXia Compiler - Lexical Analysis** 📝

*最后更新: 2025-11-26*
