# PiPiXia è¯­æ³•åˆ†æå™¨è¯¦è§£

> æœ¬æ–‡æ¡£è¯¦ç»†æè¿° PiPiXia ç¼–è¯‘å™¨çš„è¯­æ³•åˆ†æå™¨ï¼ˆParserï¼‰å®ç°ï¼Œä½¿ç”¨ Bison å·¥å…·æ„å»ºæŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰ã€‚

---

## ç›®å½•

1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [å·¥å…·å’Œé…ç½®](#å·¥å…·å’Œé…ç½®)
3. [Token å®šä¹‰](#token-å®šä¹‰)
4. [è¯­æ³•è§„åˆ™](#è¯­æ³•è§„åˆ™)
5. [AST æ„å»º](#ast-æ„å»º)
6. [è¿ç®—ç¬¦ä¼˜å…ˆçº§](#è¿ç®—ç¬¦ä¼˜å…ˆçº§)
7. [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
8. [å†…å­˜ç®¡ç†](#å†…å­˜ç®¡ç†)
9. [ç‰¹æ®Šè¯­æ³•](#ç‰¹æ®Šè¯­æ³•)

---

## æ¦‚è¿°

### è¯­æ³•åˆ†æå™¨çš„ä½œç”¨

è¯­æ³•åˆ†æå™¨ï¼ˆParserï¼‰æ¥æ”¶è¯æ³•åˆ†æå™¨ç”Ÿæˆçš„ Token æµï¼Œæ ¹æ®è¯­è¨€çš„è¯­æ³•è§„åˆ™æ„å»ºæŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰ï¼Œä¸ºåç»­çš„è¯­ä¹‰åˆ†æå’Œä»£ç ç”Ÿæˆé˜¶æ®µæä¾›ç»“æ„åŒ–çš„è¡¨ç¤ºã€‚

### å®ç°å·¥å…·

- **å·¥å…·**: Bison 3.x
- **æ–‡ä»¶**: `syntax.y`
- **è¾“å‡º**: 
  - `syntax.cc` - ç”Ÿæˆçš„ C++ ä»£ç 
  - `syntax.hh` - ç”Ÿæˆçš„å¤´æ–‡ä»¶
- **AST å®šä¹‰**: `node.h`

### ç¼–è¯‘æµç¨‹

```
æºä»£ç  (.ppx)
    â†“
è¯æ³•åˆ†æ (Flex)
    â†“
Token æµ
    â†“
è¯­æ³•åˆ†æ (Bison) â† å½“å‰é˜¶æ®µ
    â†“
æŠ½è±¡è¯­æ³•æ ‘ (AST)
    â†“
ä»£ç ç”Ÿæˆ (LLVM)
    â†“
å¯æ‰§è¡Œæ–‡ä»¶
```

---

## å·¥å…·å’Œé…ç½®

### Bison é€‰é¡¹

```bison
%{
#include <iostream>
#include <memory>
#include <vector>
#include "node.h"

extern int yylex();
extern void yyerror(const char* s);
extern int yylineno;
extern bool g_verbose;
%}

%define parse.error verbose
%define api.value.type union
```

**é…ç½®è¯´æ˜**ï¼š
- `parse.error verbose` - å¯ç”¨è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
- `api.value.type union` - ä½¿ç”¨ union ç±»å‹å­˜å‚¨è¯­ä¹‰å€¼

### è¾“å‡ºé…ç½®

```bison
%output "syntax.cc"
%defines "syntax.hh"
```

---

## Token å®šä¹‰

### åŸºæœ¬ç±»å‹ Token

```bison
/* å­—é¢é‡ */
%token <intVal> INT_LITERAL
%token <doubleVal> DOUBLE_LITERAL
%token <strVal> STRING_LITERAL
%token <strVal> INTERPOLATED_STRING
%token <charVal> CHAR_LITERAL
%token <boolVal> BOOL_LITERAL
%token <strVal> IDENTIFIER
%token <strVal> TYPE
```

### å…³é”®å­— Token

```bison
/* å…³é”®å­— */
%token LET CONST FUNC RETURN IF ELSE WHILE FOR IN IMPORT AS TRY CATCH THROW
%token BREAK CONTINUE SWITCH CASE DEFAULT
```

### è¿ç®—ç¬¦ Token

```bison
/* è¿ç®—ç¬¦ */
%token PLUS MINUS MULTIPLY DIVIDE FLOORDIV MODULO
%token EQ NE LT GT LE GE
%token AND OR NOT
%token ASSIGN PLUS_ASSIGN MINUS_ASSIGN MULT_ASSIGN DIV_ASSIGN FLOORDIV_ASSIGN MOD_ASSIGN
```

### åˆ†éš”ç¬¦ Token

```bison
/* åˆ†éš”ç¬¦ */
%token LPAREN RPAREN LBRACE RBRACE LBRACKET RBRACKET
%token COMMA COLON SEMICOLON DOT DOTDOT
```

---

## è¯­æ³•è§„åˆ™

### ç¨‹åºç»“æ„

#### é¡¶å±‚è§„åˆ™

```bison
program:
    statement_list {
        if (g_verbose) {
            std::cout << "[AST] Building program with statements" << std::endl;
        }
        $$ = new ProgramNode();
        for (auto& stmt : *$1) {
            $$->addStatement(stmt);
        }
        root = $$;
        delete $1;
    }
    ;
```

#### è¯­å¥åˆ—è¡¨

```bison
statement_list:
    statement {
        $$ = new std::vector<std::shared_ptr<StmtNode>>();
        if ($1) {
            $$->push_back(std::shared_ptr<StmtNode>($1));
        }
    }
    | statement_list statement {
        $$ = $1;
        if ($2) {
            $$->push_back(std::shared_ptr<StmtNode>($2));
        }
    }
    ;
```

### è¯­å¥ç±»å‹

#### Statement è§„åˆ™

```bison
statement:
    declaration
    | function_decl
    | if_stmt
    | while_stmt
    | for_stmt
    | return_stmt
    | break_stmt
    | continue_stmt
    | switch_stmt
    | try_catch_stmt
    | throw_stmt
    | assignment
    | expr_stmt
    | import_stmt
    | block { $$ = $1; }
    ;
```

### å˜é‡å£°æ˜

#### Let å£°æ˜

```bison
declaration:
    LET IDENTIFIER COLON type_spec ASSIGN expression {
        $$ = new VarDeclNode(*$2, std::shared_ptr<TypeNode>($4),
                            std::shared_ptr<ExprNode>($6), false);
        delete $2;
    }
    | LET IDENTIFIER COLON type_spec {
        $$ = new VarDeclNode(*$2, std::shared_ptr<TypeNode>($4),
                            nullptr, false);
        delete $2;
    }
    ;
```

#### Const å£°æ˜

```bison
    | CONST IDENTIFIER COLON type_spec ASSIGN expression {
        $$ = new VarDeclNode(*$2, std::shared_ptr<TypeNode>($4),
                            std::shared_ptr<ExprNode>($6), true);
        delete $2;
    }
```

### ç±»å‹è§„èŒƒ

```bison
type_spec:
    TYPE {
        $$ = new TypeNode(*$1);
        delete $1;
    }
    | TYPE array_dimensions {
        $$ = new TypeNode(*$1, *$2);
        delete $1;
        delete $2;
    }
    ;

array_dimensions:
    LBRACKET INT_LITERAL RBRACKET {
        $$ = new std::vector<int>();
        $$->push_back($2);
    }
    | array_dimensions LBRACKET INT_LITERAL RBRACKET {
        $$ = $1;
        $$->push_back($3);
    }
    ;
```

### å‡½æ•°å®šä¹‰

```bison
function_decl:
    FUNC IDENTIFIER LPAREN parameter_list_opt RPAREN block {
        $$ = new FunctionDeclNode(*$2, std::shared_ptr<BlockNode>($6),
                                 $4, nullptr);
        delete $2;
    }
    | FUNC IDENTIFIER LPAREN parameter_list_opt RPAREN COLON type_spec block {
        $$ = new FunctionDeclNode(*$2, std::shared_ptr<BlockNode>($8),
                                 $4, std::shared_ptr<TypeNode>($7));
        delete $2;
    }
    ;

parameter_list_opt:
    /* empty */ { $$ = nullptr; }
    | parameter_list { $$ = $1; }
    ;

parameter_list:
    parameter {
        $$ = new std::vector<std::shared_ptr<ParameterNode>>();
        $$->push_back(std::shared_ptr<ParameterNode>($1));
    }
    | parameter_list COMMA parameter {
        $$ = $1;
        $$->push_back(std::shared_ptr<ParameterNode>($3));
    }
    ;

parameter:
    IDENTIFIER COLON type_spec {
        $$ = new ParameterNode(*$1, std::shared_ptr<TypeNode>($3));
        delete $1;
    }
    ;
```

### æ§åˆ¶æµè¯­å¥

#### If è¯­å¥

```bison
if_stmt:
    IF LPAREN expression RPAREN block {
        $$ = new IfStmtNode(std::shared_ptr<ExprNode>($3),
                           std::shared_ptr<StmtNode>($5), nullptr);
    }
    | IF LPAREN expression RPAREN block ELSE block {
        $$ = new IfStmtNode(std::shared_ptr<ExprNode>($3),
                           std::shared_ptr<StmtNode>($5),
                           std::shared_ptr<StmtNode>($7));
    }
    | IF LPAREN expression RPAREN block ELSE if_stmt {
        $$ = new IfStmtNode(std::shared_ptr<ExprNode>($3),
                           std::shared_ptr<StmtNode>($5),
                           std::shared_ptr<StmtNode>($7));
    }
    ;
```

#### While å¾ªç¯

```bison
while_stmt:
    WHILE LPAREN expression RPAREN block {
        $$ = new WhileStmtNode(std::shared_ptr<ExprNode>($3),
                              std::shared_ptr<StmtNode>($5));
    }
    ;
```

#### For å¾ªç¯

```bison
for_stmt:
    FOR IDENTIFIER IN expression DOTDOT expression block {
        $$ = new ForStmtNode(*$2, std::shared_ptr<ExprNode>($4),
                            std::shared_ptr<ExprNode>($6),
                            std::shared_ptr<StmtNode>($7));
        delete $2;
    }
    ;
```

#### Switch è¯­å¥

```bison
switch_stmt:
    SWITCH expression LBRACE case_list RBRACE {
        auto switchNode = new SwitchStmtNode(std::shared_ptr<ExprNode>($2));
        if ($4) {
            for (auto& caseNode : *$4) {
                switchNode->addCase(caseNode);
            }
            delete $4;
        }
        $$ = switchNode;
    }
    ;

case_list:
    case_clause {
        $$ = new std::vector<std::shared_ptr<CaseNode>>();
        $$->push_back(std::shared_ptr<CaseNode>($1));
    }
    | case_list case_clause {
        $$ = $1;
        $$->push_back(std::shared_ptr<CaseNode>($2));
    }
    ;

case_clause:
    CASE expression COLON block {
        $$ = new CaseNode(std::shared_ptr<ExprNode>($2),
                         std::shared_ptr<BlockNode>($4));
    }
    | DEFAULT COLON block {
        $$ = new CaseNode(nullptr, std::shared_ptr<BlockNode>($3));
    }
    ;
```

#### Break å’Œ Continue

```bison
break_stmt:
    BREAK {
        $$ = new BreakStmtNode();
    }
    ;

continue_stmt:
    CONTINUE {
        $$ = new ContinueStmtNode();
    }
    ;
```

#### Return è¯­å¥

```bison
return_stmt:
    RETURN expression {
        $$ = new ReturnStmtNode(std::shared_ptr<ExprNode>($2));
    }
    | RETURN {
        $$ = new ReturnStmtNode();
    }
    ;
```

### å¼‚å¸¸å¤„ç†

```bison
try_catch_stmt:
    TRY block CATCH LPAREN IDENTIFIER COLON type_spec RPAREN block {
        $$ = new TryCatchNode(std::shared_ptr<StmtNode>($2), *$5,
                             std::shared_ptr<TypeNode>($7),
                             std::shared_ptr<StmtNode>($9));
        delete $5;
    }
    ;

throw_stmt:
    THROW expression {
        $$ = new ThrowStmtNode(std::shared_ptr<ExprNode>($2));
    }
    ;
```

### èµ‹å€¼è¯­å¥

```bison
assignment:
    postfix_expr ASSIGN expression {
        $$ = new AssignmentNode(std::shared_ptr<ExprNode>($1), "=",
                               std::shared_ptr<ExprNode>($3));
    }
    | postfix_expr PLUS_ASSIGN expression {
        $$ = new AssignmentNode(std::shared_ptr<ExprNode>($1), "+=",
                               std::shared_ptr<ExprNode>($3));
    }
    | postfix_expr MINUS_ASSIGN expression {
        $$ = new AssignmentNode(std::shared_ptr<ExprNode>($1), "-=",
                               std::shared_ptr<ExprNode>($3));
    }
    /* ... å…¶ä»–å¤åˆèµ‹å€¼è¿ç®—ç¬¦ ... */
    ;
```

### è¡¨è¾¾å¼

#### è¡¨è¾¾å¼ä¼˜å…ˆçº§å±‚æ¬¡

```
assignment_expr      (æœ€ä½ä¼˜å…ˆçº§)
    â†“
logical_or_expr      (||)
    â†“
logical_and_expr     (&&)
    â†“
equality_expr        (==, !=)
    â†“
relational_expr      (<, >, <=, >=)
    â†“
additive_expr        (+, -)
    â†“
multiplicative_expr  (*, /, //, %)
    â†“
unary_expr           (!, -)
    â†“
postfix_expr         (å‡½æ•°è°ƒç”¨, æ•°ç»„è®¿é—®, æˆå‘˜è®¿é—®)
    â†“
primary_expr         (å­—é¢é‡, æ ‡è¯†ç¬¦, æ‹¬å·è¡¨è¾¾å¼)
```

#### Primary è¡¨è¾¾å¼

```bison
primary_expr:
    INT_LITERAL {
        $$ = new IntLiteralNode($1);
    }
    | DOUBLE_LITERAL {
        $$ = new DoubleLiteralNode($1);
    }
    | STRING_LITERAL {
        $$ = new StringLiteralNode(*$1);
        delete $1;
    }
    | CHAR_LITERAL {
        $$ = new CharLiteralNode($1);
    }
    | BOOL_LITERAL {
        $$ = new BoolLiteralNode($1);
    }
    | IDENTIFIER {
        $$ = new IdentifierNode(*$1);
        delete $1;
    }
    | LPAREN expression RPAREN {
        $$ = $2;
    }
    | LBRACKET array_elements RBRACKET {
        $$ = new ArrayLiteralNode($2);
    }
    | INTERPOLATED_STRING {
        $$ = parseInterpolatedString(*$1);
        delete $1;
    }
    ;
```

#### äºŒå…ƒè¿ç®—è¡¨è¾¾å¼

```bison
multiplicative_expr:
    unary_expr
    | multiplicative_expr MULTIPLY unary_expr {
        $$ = new BinaryOpNode(std::shared_ptr<ExprNode>($1), "*",
                             std::shared_ptr<ExprNode>($3));
    }
    | multiplicative_expr DIVIDE unary_expr {
        $$ = new BinaryOpNode(std::shared_ptr<ExprNode>($1), "/",
                             std::shared_ptr<ExprNode>($3));
    }
    | multiplicative_expr FLOORDIV unary_expr {
        $$ = new BinaryOpNode(std::shared_ptr<ExprNode>($1), "//",
                             std::shared_ptr<ExprNode>($3));
    }
    | multiplicative_expr MODULO unary_expr {
        $$ = new BinaryOpNode(std::shared_ptr<ExprNode>($1), "%",
                             std::shared_ptr<ExprNode>($3));
    }
    ;

additive_expr:
    multiplicative_expr
    | additive_expr PLUS multiplicative_expr {
        $$ = new BinaryOpNode(std::shared_ptr<ExprNode>($1), "+",
                             std::shared_ptr<ExprNode>($3));
    }
    | additive_expr MINUS multiplicative_expr {
        $$ = new BinaryOpNode(std::shared_ptr<ExprNode>($1), "-",
                             std::shared_ptr<ExprNode>($3));
    }
    ;
```

#### ä¸€å…ƒè¿ç®—è¡¨è¾¾å¼

```bison
unary_expr:
    postfix_expr
    | MINUS unary_expr %prec UNARY_MINUS {
        $$ = new UnaryOpNode("-", std::shared_ptr<ExprNode>($2));
    }
    | NOT unary_expr {
        $$ = new UnaryOpNode("!", std::shared_ptr<ExprNode>($2));
    }
    ;
```

#### Postfix è¡¨è¾¾å¼

```bison
postfix_expr:
    primary_expr
    | function_call {
        $$ = $1;
    }
    | postfix_expr LBRACKET expression RBRACKET {
        $$ = new ArrayAccessNode(std::shared_ptr<ExprNode>($1),
                                std::shared_ptr<ExprNode>($3));
    }
    | postfix_expr DOT IDENTIFIER {
        $$ = new MemberAccessNode(std::shared_ptr<ExprNode>($1), *$3);
        delete $3;
    }
    ;
```

### å‡½æ•°è°ƒç”¨

```bison
function_call:
    IDENTIFIER LPAREN argument_list_opt RPAREN {
        $$ = new FunctionCallNode(*$1, $3);
        delete $1;
    }
    ;

argument_list_opt:
    /* empty */ { $$ = nullptr; }
    | argument_list { $$ = $1; }
    ;

argument_list:
    expression {
        $$ = new std::vector<std::shared_ptr<ExprNode>>();
        $$->push_back(std::shared_ptr<ExprNode>($1));
    }
    | argument_list COMMA expression {
        $$ = $1;
        $$->push_back(std::shared_ptr<ExprNode>($3));
    }
    ;
```

---

## AST æ„å»º

### AST èŠ‚ç‚¹ç±»å‹

#### åŸºç±»å®šä¹‰ (node.h)

```cpp
// åŸºç¡€ AST èŠ‚ç‚¹
class ASTNode {
public:
    virtual ~ASTNode() = default;
    virtual void print(int indent = 0) const = 0;
};

// è¡¨è¾¾å¼èŠ‚ç‚¹åŸºç±»
class ExprNode : public ASTNode {
public:
    virtual ~ExprNode() = default;
};

// è¯­å¥èŠ‚ç‚¹åŸºç±»
class StmtNode : public ASTNode {
public:
    virtual ~StmtNode() = default;
};
```

#### å…·ä½“èŠ‚ç‚¹ç±»å‹

**å­—é¢é‡èŠ‚ç‚¹**ï¼š
```cpp
class IntLiteralNode : public ExprNode {
public:
    int value;
    IntLiteralNode(int val) : value(val) {}
};

class DoubleLiteralNode : public ExprNode {
public:
    double value;
    DoubleLiteralNode(double val) : value(val) {}
};

class StringLiteralNode : public ExprNode {
public:
    std::string value;
    StringLiteralNode(const std::string& val) : value(val) {}
};
```

**è¿ç®—ç¬¦èŠ‚ç‚¹**ï¼š
```cpp
class BinaryOpNode : public ExprNode {
public:
    std::shared_ptr<ExprNode> left;
    std::string op;
    std::shared_ptr<ExprNode> right;
    
    BinaryOpNode(std::shared_ptr<ExprNode> l, const std::string& o,
                 std::shared_ptr<ExprNode> r)
        : left(l), op(o), right(r) {}
};

class UnaryOpNode : public ExprNode {
public:
    std::string op;
    std::shared_ptr<ExprNode> operand;
    
    UnaryOpNode(const std::string& o, std::shared_ptr<ExprNode> oper)
        : op(o), operand(oper) {}
};
```

**è¯­å¥èŠ‚ç‚¹**ï¼š
```cpp
class IfStmtNode : public StmtNode {
public:
    std::shared_ptr<ExprNode> condition;
    std::shared_ptr<StmtNode> thenBranch;
    std::shared_ptr<StmtNode> elseBranch;
    
    IfStmtNode(std::shared_ptr<ExprNode> cond,
               std::shared_ptr<StmtNode> then,
               std::shared_ptr<StmtNode> else_ = nullptr)
        : condition(cond), thenBranch(then), elseBranch(else_) {}
};

class WhileStmtNode : public StmtNode {
public:
    std::shared_ptr<ExprNode> condition;
    std::shared_ptr<StmtNode> body;
    
    WhileStmtNode(std::shared_ptr<ExprNode> cond,
                  std::shared_ptr<StmtNode> b)
        : condition(cond), body(b) {}
};
```

### AST éå†

ç”Ÿæˆçš„ AST å¯ä»¥é€šè¿‡å„èŠ‚ç‚¹çš„ `print()` æ–¹æ³•è¿›è¡Œå¯è§†åŒ–ï¼š

```cpp
void ProgramNode::print(int indent) const {
    std::cout << std::string(indent, ' ') << "Program:" << std::endl;
    for (const auto& stmt : statements) {
        if (stmt) stmt->print(indent + 2);
    }
}
```

---

## è¿ç®—ç¬¦ä¼˜å…ˆçº§

### ä¼˜å…ˆçº§å£°æ˜

```bison
/* è¿ç®—ç¬¦ä¼˜å…ˆçº§å’Œç»“åˆæ€§ */
%right ASSIGN PLUS_ASSIGN MINUS_ASSIGN MULT_ASSIGN DIV_ASSIGN MOD_ASSIGN
%left OR
%left AND
%left EQ NE
%left LT GT LE GE
%left PLUS MINUS
%left MULTIPLY DIVIDE FLOORDIV MODULO
%right NOT UNARY_MINUS
```

### ç»“åˆæ€§è¯´æ˜

- **å·¦ç»“åˆ (`%left`)**: 
  - ç®—æœ¯è¿ç®—ç¬¦ï¼š`+` `-` `*` `/` `//` `%`
  - æ¯”è¾ƒè¿ç®—ç¬¦ï¼š`<` `>` `<=` `>=`
  - ç›¸ç­‰è¿ç®—ç¬¦ï¼š`==` `!=`
  - é€»è¾‘è¿ç®—ç¬¦ï¼š`&&` `||`
  
- **å³ç»“åˆ (`%right`)**:
  - èµ‹å€¼è¿ç®—ç¬¦ï¼š`=` `+=` `-=` `*=` `/=` `//=` `%=`
  - ä¸€å…ƒè¿ç®—ç¬¦ï¼š`!` `-`

### ä¼˜å…ˆçº§ç¤ºä¾‹

```ppx
# è¡¨è¾¾å¼: 2 + 3 * 4
# è§£æä¸º: 2 + (3 * 4) = 14
# å› ä¸º * ä¼˜å…ˆçº§é«˜äº +

# è¡¨è¾¾å¼: a = b = 5
# è§£æä¸º: a = (b = 5)
# å› ä¸º = æ˜¯å³ç»“åˆ
```

---

## é”™è¯¯å¤„ç†

### é”™è¯¯æŠ¥å‘Š

```cpp
void yyerror(const char* s) {
    std::cerr << "Syntax error at line " << yylineno
              << ": " << s << std::endl;
    errorCount++;
}
```

### è¯¦ç»†é”™è¯¯ä¿¡æ¯

ä½¿ç”¨ `%define parse.error verbose` å¯ç”¨è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼š

```
Syntax error at line 10: unexpected token 'RBRACE', expecting 'SEMICOLON' or 'RPAREN'
```

### é”™è¯¯æ¢å¤

Bison è‡ªåŠ¨è¿›è¡Œé”™è¯¯æ¢å¤ï¼Œå°è¯•è·³è¿‡é”™è¯¯çš„ token ç»§ç»­è§£æï¼š

```bison
statement:
    declaration
    | /* ... */
    | error SEMICOLON {
        yyerrok;
        $$ = nullptr;
    }
    ;
```

---

## å†…å­˜ç®¡ç†

### æ™ºèƒ½æŒ‡é’ˆä½¿ç”¨

æ‰€æœ‰ AST èŠ‚ç‚¹ä½¿ç”¨ `std::shared_ptr` ç®¡ç†ï¼š

```cpp
std::shared_ptr<ExprNode> expr;
std::shared_ptr<StmtNode> stmt;
std::shared_ptr<BlockNode> block;
```

### Destructor å£°æ˜

ä¸ºè§£æé”™è¯¯æ—¶æ¸…ç†åŠ¨æ€åˆ†é…çš„å†…å­˜ï¼š

```bison
%destructor { delete $$; } <strVal>
%destructor { delete $$; } <expr>
%destructor { delete $$; } <stmt>
%destructor { delete $$; } <type>
%destructor { delete $$; } <param>
%destructor { delete $$; } <block>
%destructor { delete $$; } <funcCall>
%destructor { delete $$; } <caseNode>
%destructor { delete $$; } <paramList>
%destructor { delete $$; } <exprList>
%destructor { delete $$; } <intList>
%destructor { delete $$; } <caseList>
```

---

## ç‰¹æ®Šè¯­æ³•

### æ’å€¼å­—ç¬¦ä¸²è§£æ

æ’å€¼å­—ç¬¦ä¸²éœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œè§£æ `${}` ä¸­çš„è¡¨è¾¾å¼ï¼š

```cpp
ExprNode* parseInterpolatedString(const std::string& str) {
    std::vector<std::shared_ptr<ExprNode>> parts;
    size_t pos = 0;
    
    while (pos < str.length()) {
        size_t start = str.find("${", pos);
        
        if (start == std::string::npos) {
            // å‰©ä½™çš„æ™®é€šæ–‡æœ¬
            if (pos < str.length()) {
                std::string text = str.substr(pos);
                parts.push_back(std::make_shared<StringLiteralNode>(text));
            }
            break;
        }
        
        // æ‰¾åˆ° ${} ä¸­çš„è¡¨è¾¾å¼
        size_t end = str.find("}", start + 2);
        std::string exprText = str.substr(start + 2, end - start - 2);
        
        // è§£æè¡¨è¾¾å¼
        ExprNode* expr = parseSimpleExpr(exprText);
        parts.push_back(std::shared_ptr<ExprNode>(expr));
        
        pos = end + 1;
    }
    
    return new InterpolatedStringNode(parts);
}
```

### ç®€å•è¡¨è¾¾å¼è§£æå™¨

ç”¨äºè§£ææ’å€¼å­—ç¬¦ä¸²ä¸­çš„è¡¨è¾¾å¼ï¼š

```cpp
class SimpleTokenizer {
    std::string input;
    size_t pos;
    
public:
    SimpleTokenizer(const std::string& str) : input(str), pos(0) {}
    
    Token nextToken() {
        skipWhitespace();
        
        if (pos >= input.length()) {
            return Token{TokenType::END, ""};
        }
        
        // è¯†åˆ«æ•°å­—ã€æ ‡è¯†ç¬¦ã€è¿ç®—ç¬¦ç­‰
        // ...
    }
};
```

### æ•°ç»„å­—é¢é‡

```bison
array_elements:
    expression {
        $$ = new std::vector<std::shared_ptr<ExprNode>>();
        $$->push_back(std::shared_ptr<ExprNode>($1));
    }
    | array_elements COMMA expression {
        $$ = $1;
        $$->push_back(std::shared_ptr<ExprNode>($3));
    }
    ;
```

---

## è¯­æ³•æ ‘å¯è§†åŒ–

### AST æ‰“å°ç¤ºä¾‹

è¾“å…¥ä»£ç ï¼š
```ppx
func main(): int {
    let x: int = 10 + 20
    return x
}
```

AST è¾“å‡ºï¼š
```
Program:
  FunctionDecl: main
    Return Type: int
    Parameters: (none)
    Body:
      VarDecl: x
        Type: int
        Init:
          BinaryOp: +
            IntLiteral: 10
            IntLiteral: 20
      ReturnStmt:
        Identifier: x
```

---

## è¯­æ³•è§„åˆ™å®Œæ•´åˆ—è¡¨

### å·²å®ç°çš„è¯­æ³•ç‰¹æ€§

1. **åŸºæœ¬ç»“æ„**
   - âœ… ç¨‹åºå’Œè¯­å¥åˆ—è¡¨
   - âœ… ä»£ç å— `{ }`

2. **å£°æ˜**
   - âœ… å˜é‡å£°æ˜ `let`
   - âœ… å¸¸é‡å£°æ˜ `const`
   - âœ… å‡½æ•°å£°æ˜ `func`
   - âœ… ç±»å‹æ³¨è§£

3. **æ§åˆ¶æµ**
   - âœ… If-else è¯­å¥
   - âœ… While å¾ªç¯
   - âœ… For å¾ªç¯
   - âœ… Switch-case è¯­å¥
   - âœ… Break è¯­å¥
   - âœ… Continue è¯­å¥
   - âœ… Return è¯­å¥

4. **è¡¨è¾¾å¼**
   - âœ… å­—é¢é‡ï¼ˆint, double, string, char, boolï¼‰
   - âœ… æ ‡è¯†ç¬¦
   - âœ… äºŒå…ƒè¿ç®—ç¬¦
   - âœ… ä¸€å…ƒè¿ç®—ç¬¦
   - âœ… å‡½æ•°è°ƒç”¨
   - âœ… æ•°ç»„è®¿é—®
   - âœ… æˆå‘˜è®¿é—®
   - âœ… æ•°ç»„å­—é¢é‡
   - âœ… æ’å€¼å­—ç¬¦ä¸²

5. **èµ‹å€¼**
   - âœ… åŸºæœ¬èµ‹å€¼ `=`
   - âœ… å¤åˆèµ‹å€¼ `+=` `-=` `*=` `/=` `//=` `%=`

6. **å¼‚å¸¸å¤„ç†**
   - âœ… Try-catch è¯­å¥
   - âœ… Throw è¯­å¥

7. **æ¨¡å—ç³»ç»Ÿ**
   - âœ… Import è¯­å¥
   - âœ… Import with alias

---

## è°ƒè¯•å’Œæµ‹è¯•

### å¯ç”¨è¯¦ç»†è¾“å‡º

è®¾ç½®å…¨å±€å˜é‡ `g_verbose = true` æŸ¥çœ‹è§£æè¿‡ç¨‹ï¼š

```
[AST] Parsing program
[AST] Parsing function declaration: main
[AST] Parsing variable declaration: x
[AST] Parsing binary operation: +
[AST] Parsing return statement
```

### è¯­æ³•æ ‘éªŒè¯

ç¼–è¯‘æ—¶ä½¿ç”¨ `-ast` é€‰é¡¹è¾“å‡º ASTï¼š

```bash
./compiler program.ppx -ast
```

### å¸¸è§è¯­æ³•é”™è¯¯

1. **ç¼ºå°‘åˆ†å·**
   ```
   Error: unexpected token '}', expecting ';'
   ```

2. **æ‹¬å·ä¸åŒ¹é…**
   ```
   Error: unexpected end of file, expecting ')'
   ```

3. **ç±»å‹å£°æ˜é”™è¯¯**
   ```
   Error: unexpected token 'IDENTIFIER', expecting 'TYPE'
   ```

---

## æ€§èƒ½ä¼˜åŒ–

### å‡å°‘è§„åˆ™æ•°é‡

**åˆå¹¶ç›¸ä¼¼è§„åˆ™**ï¼š
```bison
/* ä¸æ¨è */
stmt: if_stmt | while_stmt | for_stmt | return_stmt;

/* æ¨è */
stmt:
    if_stmt
    | while_stmt
    | for_stmt
    | return_stmt
    ;
```

### å·¦é€’å½’ä¼˜åŒ–

**ä½¿ç”¨å·¦é€’å½’è€Œéå³é€’å½’**ï¼š
```bison
/* å¥½çš„åšæ³•ï¼ˆå·¦é€’å½’ï¼‰ */
expr_list:
    expr
    | expr_list COMMA expr
    ;

/* ä¸æ¨èï¼ˆå³é€’å½’ï¼Œä¼šå¯¼è‡´æ·±åº¦æ ˆè°ƒç”¨ï¼‰ */
expr_list:
    expr
    | expr COMMA expr_list
    ;
```

### å‡å°‘è¯­ä¹‰åŠ¨ä½œå¤æ‚åº¦

**å°†å¤æ‚é€»è¾‘ç§»åˆ°è¾…åŠ©å‡½æ•°**ï¼š
```bison
/* ä¸æ¨è */
expr: IDENTIFIER {
    // å¤§é‡å¤æ‚ä»£ç ...
    $$ = ...;
}

/* æ¨è */
expr: IDENTIFIER {
    $$ = createIdentifierNode(*$1);
    delete $1;
}
```

---

## å¸¸è§è¯­æ³•æ¨¡å¼

### å¯é€‰é¡¹æ¨¡å¼

```bison
/* æ¨¡å¼ï¼šX_opt è¡¨ç¤ºå¯é€‰çš„ X */
parameter_list_opt:
    /* empty */ { $$ = nullptr; }
    | parameter_list { $$ = $1; }
    ;
```

### åˆ—è¡¨æ¨¡å¼

```bison
/* æ¨¡å¼ï¼šè‡³å°‘ä¸€ä¸ªå…ƒç´ çš„åˆ—è¡¨ */
statement_list:
    statement {
        $$ = new std::vector<StmtNode*>();
        $$->push_back($1);
    }
    | statement_list statement {
        $1->push_back($2);
        $$ = $1;
    }
    ;
```

### è¡¨è¾¾å¼ä¼˜å…ˆçº§æ¨¡å¼

```bison
/* æ¨¡å¼ï¼šé€šè¿‡è¯­æ³•å±‚æ¬¡è¡¨ç¤ºä¼˜å…ˆçº§ */
expr:
    term
    | expr PLUS term
    | expr MINUS term
    ;

term:
    factor
    | term MULTIPLY factor
    | term DIVIDE factor
    ;

factor:
    primary
    | MINUS factor
    ;
```

---

## è¯­æ³•è®¾è®¡å»ºè®®

### 1. ä¿æŒè§„åˆ™ç®€æ´

```bison
/* å¥½çš„è®¾è®¡ */
if_stmt:
    IF LPAREN expression RPAREN block
    | IF LPAREN expression RPAREN block ELSE block
    ;

/* é¿å…è¿‡åº¦å¤æ‚ */
if_stmt:
    IF LPAREN expression RPAREN block optional_else
    ;
```

### 2. ä½¿ç”¨æœ‰æ„ä¹‰çš„éç»ˆç»“ç¬¦åç§°

```bison
/* æ¸…æ™° */
function_declaration:
    FUNC IDENTIFIER LPAREN parameter_list RPAREN block
    ;

/* ä¸æ¸…æ™° */
func_decl:
    F ID LP params RP blk
    ;
```

### 3. ä¿æŒä¸€è‡´çš„ä»£ç é£æ ¼

```bison
/* ç»Ÿä¸€çš„ç¼©è¿›å’Œå‘½å */
declaration:
    var_decl
    | const_decl
    | func_decl
    ;

var_decl:
    LET IDENTIFIER COLON type_spec ASSIGN expression
    ;
```

---

## é”™è¯¯æ¢å¤ç­–ç•¥

### åŸºæœ¬é”™è¯¯æ¢å¤

```bison
statement:
    /* æ­£å¸¸è¯­å¥ */
    declaration
    | assignment
    | /* ... */
    /* é”™è¯¯æ¢å¤ */
    | error SEMICOLON {
        yyerrok;
        $$ = nullptr;
    }
    ;
```

### å—çº§é”™è¯¯æ¢å¤

```bison
block:
    LBRACE statement_list RBRACE
    | LBRACE error RBRACE {
        yyerrok;
        $$ = new BlockNode();
    }
    ;
```

---

## è°ƒè¯•å’ŒéªŒè¯æ¸…å•

### ç¼–è¯‘å‰æ£€æŸ¥

- [ ] æ‰€æœ‰éç»ˆç»“ç¬¦éƒ½æœ‰å®šä¹‰
- [ ] æ‰€æœ‰ Token éƒ½å·²å£°æ˜
- [ ] è¯­ä¹‰åŠ¨ä½œä¸­çš„ç±»å‹åŒ¹é…
- [ ] å†…å­˜ç®¡ç†æ­£ç¡®ï¼ˆnew/delete é…å¯¹ï¼‰
- [ ] ä¼˜å…ˆçº§å£°æ˜å®Œæ•´

### æµ‹è¯•ç”¨ä¾‹

```ppx
# åŸºæœ¬åŠŸèƒ½æµ‹è¯•
- ç©ºç¨‹åº
- å•ä¸ªè¯­å¥
- å¤šä¸ªè¯­å¥
- åµŒå¥—ç»“æ„
- è¾¹ç•Œæƒ…å†µ

# é”™è¯¯å¤„ç†æµ‹è¯•
- è¯­æ³•é”™è¯¯
- ç±»å‹é”™è¯¯
- æœªé—­åˆçš„æ‹¬å·
- ç¼ºå°‘åˆ†å·
```

---

## å‚è€ƒèµ„æº

### ç›¸å…³æ–‡æ¡£

- [è¯æ³•åˆ†ææ–‡æ¡£](../document/è¯æ³•åˆ†æ.md) - Flex è¯æ³•åˆ†æå™¨
- [AST èŠ‚ç‚¹å®šä¹‰](../node.h) - å®Œæ•´çš„ AST ç±»å®šä¹‰
- [ä»£ç ç”Ÿæˆæ–‡æ¡£](../codegen.h) - LLVM ä»£ç ç”Ÿæˆ

### å¤–éƒ¨èµ„æº

- [Bison å®˜æ–¹æ–‡æ¡£](https://www.gnu.org/software/bison/manual/)
- [C++ æ™ºèƒ½æŒ‡é’ˆæŒ‡å—](https://en.cppreference.com/w/cpp/memory)
- [ç¼–è¯‘åŸç†æ•™æ](https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools)

---

## é™„å½•ï¼šå®Œæ•´è¯­æ³•å›¾

```
Program
  â””â”€â”€ Statement*
        â”œâ”€â”€ VarDecl (let/const)
        â”œâ”€â”€ FunctionDecl
        â”‚     â”œâ”€â”€ Parameters
        â”‚     â”œâ”€â”€ ReturnType
        â”‚     â””â”€â”€ Block
        â”œâ”€â”€ IfStmt
        â”‚     â”œâ”€â”€ Condition
        â”‚     â”œâ”€â”€ ThenBranch
        â”‚     â””â”€â”€ ElseBranch?
        â”œâ”€â”€ WhileStmt
        â”‚     â”œâ”€â”€ Condition
        â”‚     â””â”€â”€ Body
        â”œâ”€â”€ ForStmt
        â”‚     â”œâ”€â”€ Variable
        â”‚     â”œâ”€â”€ Start
        â”‚     â”œâ”€â”€ End
        â”‚     â””â”€â”€ Body
        â”œâ”€â”€ SwitchStmt
        â”‚     â”œâ”€â”€ Condition
        â”‚     â””â”€â”€ Cases*
        â”‚           â”œâ”€â”€ CaseValue
        â”‚           â””â”€â”€ CaseBody
        â”œâ”€â”€ TryCatch
        â”‚     â”œâ”€â”€ TryBlock
        â”‚     â””â”€â”€ CatchBlock
        â”œâ”€â”€ Return
        â”œâ”€â”€ Break
        â”œâ”€â”€ Continue
        â”œâ”€â”€ Throw
        â”œâ”€â”€ Assignment
        â””â”€â”€ Expression
```

---

**PiPiXia Compiler - Syntax Analysis** ğŸ”

*æœ€åæ›´æ–°: 2025-11-26*
